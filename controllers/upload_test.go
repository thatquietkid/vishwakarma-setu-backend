package controllers

import (
	"bytes"
	"encoding/json"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
)

func TestUploadImage_Success(t *testing.T) {
	e := echo.New()

	// 1. Prepare Multipart Form Data
	body := new(bytes.Buffer)
	writer := multipart.NewWriter(body)
	// Create a form file field 'file' with filename 'test_image.jpg'
	part, err := writer.CreateFormFile("file", "test_image.jpg")
	if err != nil {
		t.Fatal(err)
	}
	// Write dummy image content
	part.Write([]byte("fake image binary data"))
	writer.Close()

	// 2. Create Request
	req := httptest.NewRequest(http.MethodPost, "/api/upload", body)
	// Important: Set the Content-Type header generated by the writer (includes boundary)
	req.Header.Set(echo.HeaderContentType, writer.FormDataContentType())

	// 3. Mock Auth
	testToken := createTestToken(1, "seller")
	req.Header.Set(echo.HeaderAuthorization, "Bearer "+testToken)

	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	// Manually set token in context since we skip middleware
	token, _ := jwt.ParseWithClaims(testToken, new(jwt.MapClaims), func(token *jwt.Token) (interface{}, error) {
		return []byte(os.Getenv("JWT_SECRET")), nil
	})
	c.Set("user", token)

	// 4. Execute
	if err := UploadImage(c); err != nil {
		t.Fatalf("handler error: %v", err)
	}

	// 5. Assertions
	if rec.Code != http.StatusCreated {
		t.Errorf("expected status 201 Created, got %d. Body: %s", rec.Code, rec.Body.String())
	}

	var resp map[string]string
	if err := json.Unmarshal(rec.Body.Bytes(), &resp); err != nil {
		t.Fatalf("invalid response json: %v", err)
	}

	// Verify URL format
	url, ok := resp["url"]
	if !ok {
		t.Fatal("response missing 'url' field")
	}
	if !strings.HasPrefix(url, "/uploads/upload-") || !strings.HasSuffix(url, ".jpg") {
		t.Errorf("unexpected url format: %s", url)
	}

	// Cleanup: Remove the created file
	// The controller writes to ./uploads/, so we map the relative URL back to fs path
	if strings.HasPrefix(url, "/uploads/") {
		// "./uploads/filename.jpg"
		filePath := "." + url
		os.Remove(filePath)
	}
}

func TestUploadImage_InvalidExtension(t *testing.T) {
	e := echo.New()
	body := new(bytes.Buffer)
	writer := multipart.NewWriter(body)
	// Use .txt extension which should be rejected
	part, err := writer.CreateFormFile("file", "malicious.txt")
	if err != nil {
		t.Fatal(err)
	}
	part.Write([]byte("text content"))
	writer.Close()

	req := httptest.NewRequest(http.MethodPost, "/api/upload", body)
	req.Header.Set(echo.HeaderContentType, writer.FormDataContentType())

	testToken := createTestToken(1, "seller")
	req.Header.Set(echo.HeaderAuthorization, "Bearer "+testToken)

	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	
	token, _ := jwt.ParseWithClaims(testToken, new(jwt.MapClaims), func(token *jwt.Token) (interface{}, error) {
		return []byte(os.Getenv("JWT_SECRET")), nil
	})
	c.Set("user", token)

	UploadImage(c)

	if rec.Code != http.StatusBadRequest {
		t.Errorf("expected status 400 Bad Request for invalid ext, got %d", rec.Code)
	}
}

func TestUploadImage_NoFile(t *testing.T) {
	e := echo.New()
	// Send request without body/form-data
	req := httptest.NewRequest(http.MethodPost, "/api/upload", nil)
	
	testToken := createTestToken(1, "seller")
	req.Header.Set(echo.HeaderAuthorization, "Bearer "+testToken)

	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	
	token, _ := jwt.ParseWithClaims(testToken, new(jwt.MapClaims), func(token *jwt.Token) (interface{}, error) {
		return []byte(os.Getenv("JWT_SECRET")), nil
	})
	c.Set("user", token)

	UploadImage(c)

	// Should fail because "file" form field is missing
	if rec.Code != http.StatusBadRequest {
		t.Errorf("expected status 400 Bad Request for missing file, got %d", rec.Code)
	}
}